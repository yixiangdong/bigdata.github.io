{"meta":{"title":"大数据商务智能(BI)专栏","subtitle":"专注 系统 专业 ","description":"大数据商务智能(BI)方案设计","author":"易向东","url":"https://yixiangdong.github.io","root":"/"},"pages":[],"posts":[{"title":"阿里云Dataworks+Maxcompute实时计算数据仓库方案之业务数仓搭建(二)","slug":"ceshi2","date":"2020-03-19T19:57:06.000Z","updated":"2020-03-19T20:57:04.439Z","comments":true,"path":"2020/03/20/ceshi2/","link":"","permalink":"https://yixiangdong.github.io/2020/03/20/ceshi2/","excerpt":"","text":"业务数仓搭建业务数仓架构图业务数仓系统流程设计","categories":[],"tags":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://yixiangdong.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}]},{"title":"阿里云Dataworks+Maxcompute实时计算数据仓库方案之用户行为数仓搭建(一)","slug":"ceshi","date":"2020-03-19T03:12:23.000Z","updated":"2020-03-19T19:56:09.023Z","comments":true,"path":"2020/03/19/ceshi/","link":"","permalink":"https://yixiangdong.github.io/2020/03/19/ceshi/","excerpt":"","text":"数据仓库概念数据仓库定义(Data Warehouse)是为企业所有决策制定过程，提供所有系统数据支持的战略集合。数据仓库好处：可以帮助企业， 改进业务流程、 控制成本、 提高产品质量等。数据仓库做什么： 清洗，转义，分类，重组，合并，拆分，统计等。数据仓库输出到哪： 报表系统、用户画像、推荐系统、机器学习、风控系统等 项目需求分析 采集埋点日志数据 采集业务数据库中数据 数据仓库的搭建（用户行为数仓、业务数仓） 分析统计业务指标 对结果进行可视化展示 项目框架阿里云产品 简介 类比 系统数据流程设计 技术选型 数据生成模块埋点数据基本格式1）公共字段：基本所有安卓手机都包含的字段 2） 业务字段：埋点上报的字段，有具体的业务类型 下面就是一个示例，表示业务字段的上传。 {“ap”:”xxxxx”,//项目数据来源 app pc “cm”: { //公共字段“mid”: “”, // (String) 设备唯一标识“uid”: “”, // (String) 用户标识“vc”: “1”, // (String) versionCode，程序版本号“vn”: “1.0”, // (String) versionName，程序版本名“l”: “zh”, // (String) language 系统语言“sr”: “”, // (String) 渠道号，应用从哪个渠道来的。“os”: “7.1.1”, // (String) Android 系统版本“ar”: “CN”, // (String) area 区域“md”: “BBB100-1”, // (String) model 手机型号“ba”: “blackberry”, // (String) brand 手机品牌“sv”: “V2.2.1”, // (String) sdkVersion“g”: “”, // (String) gmail“hw”: “1620x1080”, // (String) heightXwidth，屏幕宽高“t”: “1506047606608”, // (String) 客户端日志产生时的时间“nw”: “WIFI”, // (String) 网络模式“ln”: 0, // (double) lng 经度“la”: 0 // (double) lat 纬度},“et”: [ //事件{“ett”: “1506047605364”, //客户端事件产生时间“en”: “display”, //事件名称“kv”: { //事件结果，以 key-value 形式自行定义“goodsid”: “236”,“action”: “1”,“extend1”: “1”,“place”: “2”,“category”: “75”}}]} 示例日志（服务器时间戳 | 日志） ： 1540934156385|{“ap”: “gmall”,“cm”: {“uid”: “1234”,“vc”: “2”,“vn”: “1.0”,“la”: “EN”,“sr”: “”,“os”: “7.1.1”,“ar”: “CN”,“md”: “BBB100-1”,“ba”: “blackberry”,“sv”: “V2.2.1”,“g”: “abc@gmail.com“,“hw”: “1620x1080”,“t”: “1506047606608”,“nw”: “WIFI”,“ln”: 0},“et”: [ {“ett”: “1506047605364”, //客户端事件产生时间“en”: “display”, //事件名称“kv”: { //事件结果，以 key-value 形式自行定义“goodsid”: “236”,“action”: “1”,“extend1”: “1”,“place”: “2”,“category”: “75”}},{“ett”: “1552352626835”,“en”: “error”,“kv”: {“errorBrief”: “错误摘要”,“errorDetail”: “错误详情”}}]} } 下面是各个埋点日志格式。 其中商品点击属于信息流的范畴3.2 事件日志数据3.2.1 商品列表页（loading）事件名称： loading 标签 含义 action 动作：开始加载=1，加载成功=2，加载失败=3 loading_time 加载时长：计算下拉开始到接口返回数据的时间，（开始加载报 0，加载成 功或加载失败才上报时间） loading_way 加载类型： 1-读取缓存， 2-从接口拉新数据 （加载成功才上报加载类型） extend1 扩展字段 Extend1 extend2 扩展字段 Extend2 type 加载类型：自动加载=1，用户下拽加载=2，底部加载=3（底部条触发点击 底部提示条/点击返回顶部加载） type1 加载失败码：把加载失败状态码报回来（报空为加载成功，没有失败） 商品曝光（display） 标签 含义 action 动作：曝光商品=1，点击商品=2， goodsid 商品 ID（服务端下发的 ID） place 顺序（第几条商品，第一条为 0，第二条为 1，如此类推） extend1 曝光类型： 1 - 首次曝光 2-重复曝光 category 分类 ID（服务端定义的分类 ID） 商品详情页 action 动作：开始加载=1，加载成功=2（ pv），加载失败=3, 退出页面=4 goodsid 商品 ID（服务端下发的 ID） show_style 商品样式： 0、无图、 1、一张大图、 2、两张图、 3、三张小图、 4、一张小图、 5、 一张大图两张小图 news_staytime 页面停留时长：从商品开始加载时开始计算，到用户关闭页面所用的时间。若中途 用跳转到其它页面了，则暂停计时，待回到详情页时恢复计时。或中途划出的时间 超过 10 分钟，则本次计时作废，不上报本次数据。如未加载成功退出，则报空。 loading_time 加载时长：计算页面开始加载到接口返回数据的时间 （开始加载报 0，加载成功或 加载失败才上报时间） type1 加载失败码：把加载失败状态码报回来（报空为加载成功，没有失败） category 分类 ID（服务端定义的分类 ID） 购物车（cart） 标签 含义 itemid 商品 action 操作类型： 1 添加购物车； 2 改变商品数量； 3 移除商品 change_num 加减数量 before_num 更改前数量 after_num 更改后数量 price 商品单价 广告（ad） 标签 含义 entry 入口：商品列表页=1 应用首页=2 商品详情页=3 action 动作：请求广告=1 取缓存广告=2 广告位展示=3 广告展示=4 广告点击=5 content 状态：成功=1 失败=2 detail 失败码（没有则上报空） source 广告来源:admob=1 facebook=2 ADX（百度） =3 VK（头条） =4 behavior 用户行为： 主动获取广告=1 被动获取广告=2 newstype Type: 1- 图文 2-图集 3-段子 4-GIF 5-视频 6-调查 7-纯文 8-视频+图文 9-GI F+图文 0-其他 show_style 内容样式：无图(纯文字)=6 一张大图=1 三站小图+文=4 一张小图=2 一张大图 两张小图+文=3 图集+文 = 5 一张大图+文=11 GIF 大图+文=12 视频(大图)+文 = 13 来源于详情页相关推荐的商品，上报样式都为 0（因为都是左文右图） 消息通知（notification） 标签 含义 action 动作：通知产生=1，通知弹出=2，通知点击=3，常驻通知展示（不重复上报， 一天之内只报一次） =4 type 通知 id：预警通知=1，天气预报（早=2，晚=3），常驻=4 ap_time 客户端弹出时间 content 备用字段 评论（comment） 标签 含义 字段类型 长度 允许空 缺省值 comment_id 评论表 int 10,0 userid 用户 id int 10,0 √ 0 p_comment_id 父级评论 id(为 0 则是一 级评论,不为 0 则是回复) int 10,0 √ content 评论内容 string 1000 √ addtime 创建时间 string √ other_id 评论的相关 id int 10,0 √ praise_count 点赞数量 int 10,0 √ 0 reply_count 回复数量 int 10,0 √ 0 收藏（favorites） 标签 含义 字段类型 长度 允许空 缺省值 id 主键 int 10,0 course_id 商品 id int 10,0 √ 0 userid 用户 ID int 10,0 √ 0 add_time 创建时间 string √ 点赞（praise） 标签 含义 字段类型 长度 允许空 缺省值 id 主键 id int 10,0 userid 用户 id int 10,0 √ target_id 点赞的对象 id int 10,0 √ type 点赞类型 1 问答点赞 2 问 答评论点赞 3 文章点赞数 4 评论点赞 int 10,0 √ add_time 添加时间 string √ 错误日志（error） 标签 含义 errorBrief 错误摘要 errorDetail 错误详情 启动日志数据（start） 标签 含义 entry 入 口 ： push=1 ， widget=2 ， icon=3 ， notification=4, lockscreen_widget =5 open_ad_type 开屏广告类型: 开屏原生广告=1, 开屏插屏广告=2 action 状态：成功=1 失败=2 loading_time 加载时长：计算下拉开始到接口返回数据的时间，（开始加载报 0，加载 成功或加载失败才上报时间） detail 失败码（没有则上报空） extend1 失败的 message（没有则上报空） en 日志类型 start 数据生成脚本创建 Maven 工程1） 创建 log-collector 2）创建一个包名： com.atguigu.appclient3） 在 com.atguigu.appclient 包下创建一个类， AppMain。4） 在 pom.xml 文件中添加如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!--版本号统一--&gt;&lt;properties&gt;&lt;slf4j.version&gt;1.7.20&lt;/slf4j.version&gt;&lt;logback.version&gt;1.0.7&lt;/logback.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--阿里巴巴开源 json 解析框架--&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;/groupId&gt;&lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;version&gt;1.2.51&lt;/version&gt;&lt;/dependency&gt;&lt;!--日志生成框架--&gt;&lt;dependency&gt;&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&lt;artifactId&gt;logback-core&lt;/artifactId&gt;&lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--编译打包插件--&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;version&gt;2.3.2&lt;/version&gt;&lt;configuration&gt;&lt;source&gt;1.8&lt;/source&gt;&lt;target&gt;1.8&lt;/target&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt;&lt;artifactId&gt;maven-assembly-plugin &lt;/artifactId&gt;&lt;configuration&gt;&lt;descriptorRefs&gt;&lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;&lt;/descriptorRefs&gt;&lt;archive&gt;&lt;manifest&gt;&lt;mainClass&gt;com.atguigu.appclient.AppMain&lt;/mainClass&gt;&lt;/manifest&gt;&lt;/archive&gt;&lt;/configuration&gt;&lt;executions&gt;&lt;execution&gt;&lt;id&gt;make-assembly&lt;/id&gt;&lt;phase&gt;package&lt;/phase&gt;&lt;goals&gt;&lt;goal&gt;single&lt;/goal&gt;&lt;/goals&gt;&lt;/execution&gt;&lt;/executions&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 注意： com.atguigu.appclient.AppMain 要和自己建的全类名一致。 公共字段 Bean1） 创建包名： com.atguigu.bean2） 在 com.atguigu.bean 包下依次创建如下 bean 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.atguigu.bean;/***公共日志*/public class AppBase&#123;private String mid; // (String) 设备唯一标识private String uid; // (String) 用户 uidprivate String vc; // (String) versionCode，程序版本号private String vn; // (String) versionName，程序版本名private String l; // (String) 系统语言private String sr; // (String) 渠道号，应用从哪个渠道来的。private String os; // (String) Android 系统版本private String ar; // (String) 区域private String md; // (String) 手机型号private String ba; // (String) 手机品牌private String sv; // (String) sdkVersionprivate String g; // (String) gmail private String hw; // (String) heightXwidth，屏幕宽高private String t; // (String) 客户端日志产生时的时间private String nw; // (String) 网络模式private String ln; // (double) lng 经度private String la; // (double) lat 纬度public String getMid() &#123;return mid;&#125;public void setMid(String mid) &#123;this.mid = mid;&#125;public String getUid() &#123;return uid;&#125;public void setUid(String uid) &#123;this.uid = uid;&#125;public String getVc() &#123;return vc;&#125;public void setVc(String vc) &#123;this.vc = vc;&#125;public String getVn() &#123;return vn;&#125;public void setVn(String vn) &#123;this.vn = vn;&#125;public String getL() &#123;return l;&#125;public void setL(String l) &#123;this.l = l;&#125;public String getSr() &#123;return sr;&#125;public void setSr(String sr) &#123;this.sr = sr;&#125;public String getOs() &#123;return os;&#125;public void setOs(String os) &#123;this.os = os;&#125;public String getAr() &#123; return ar;&#125;public void setAr(String ar) &#123;this.ar = ar;&#125;public String getMd() &#123;return md;&#125;public void setMd(String md) &#123;this.md = md;&#125;public String getBa() &#123;return ba;&#125;public void setBa(String ba) &#123;this.ba = ba;&#125;public String getSv() &#123;return sv;&#125;public void setSv(String sv) &#123;this.sv = sv;&#125;public String getG() &#123;return g;&#125;public void setG(String g) &#123;this.g = g;&#125;public String getHw() &#123;return hw;&#125;public void setHw(String hw) &#123;this.hw = hw;&#125;public String getT() &#123;return t;&#125;public void setT(String t) &#123;this.t = t;&#125;public String getNw() &#123;return nw;&#125;public void setNw(String nw) &#123;this.nw = nw;&#125; public String getLn() &#123;return ln;&#125;public void setLn(String ln) &#123;this.ln = ln;&#125;public String getLa() &#123;return la;&#125;public void setLa(String la) &#123;this.la = la;&#125;&#125; 启动日志 Bean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.bean;/*** 启动日志*/public class AppStart extends AppBase &#123;private String entry;//入口： push=1， widget=2， icon=3， notification=4,lockscreen_widget =5private String open_ad_type;//开屏广告类型: 开屏原生广告=1, 开屏插屏广告=2private String action;//状态：成功=1 失败=2private String loading_time;//加载时长：计算下拉开始到接口返回数据的时间，（开始加载报 0，加载成功或加载失败才上报时间）private String detail;//失败码（没有则上报空）private String extend1;//失败的 message（没有则上报空）private String en;//启动日志类型标记public String getEntry() &#123;return entry;&#125;public void setEntry(String entry) &#123;this.entry = entry;&#125;public String getOpen_ad_type() &#123;return open_ad_type;&#125;public void setOpen_ad_type(String open_ad_type) &#123;this.open_ad_type = open_ad_type;&#125;public String getAction() &#123;return action;&#125;public void setAction(String action) &#123;this.action = action;&#125;public String getLoading_time() &#123;return loading_time;&#125;public void setLoading_time(String loading_time) &#123;this.loading_time = loading_time;&#125;public String getDetail() &#123;return detail;&#125;public void setDetail(String detail) &#123;this.detail = detail;&#125;public String getExtend1() &#123;return extend1;&#125;public void setExtend1(String extend1) &#123;this.extend1 = extend1;&#125;public String getEn() &#123;return en;&#125;public void setEn(String en) &#123;this.en = en;&#125;&#125; 错误日志 Bean1234567891011121314151617181920package com.atguigu.bean;/*** 错误日志*/public class AppError &#123;private String errorBrief; //错误摘要private String errorDetail; //错误详情public String getErrorBrief() &#123;return errorBrief;&#125;public void setErrorBrief(String errorBrief) &#123;this.errorBrief = errorBrief;&#125;public String getErrorDetail() &#123;return errorDetail;&#125;public void setErrorDetail(String errorDetail) &#123;this.errorDetail = errorDetail;&#125;&#125; 事件日志 Bean 之商品曝光123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.bean;/**** 商品点击日志 */ public class AppDisplay &#123; private String action;//动作：曝光商品=1，点击商品=2， private String goodsid;//商品 ID（服务端下发的 ID） private String place;//顺序（第几条商品，第一条为 0，第二条为 1，如此类推） private String extend1;//曝光类型： 1 - 首次曝光 2-重复曝光（没有使用） private String category;//分类 ID（服务端定义的分类 ID） public String getAction() &#123; return action; &#125; public void setAction(String action) &#123; this.action = action; &#125; public String getGoodsid() &#123; return goodsid; &#125; public void setGoodsid(String goodsid) &#123; this.goodsid = goodsid; &#125; public String getPlace() &#123; return place; &#125; public void setPlace(String place) &#123; this.place = place; &#125; public String getExtend1() &#123; return extend1; &#125; public void setExtend1(String extend1) &#123; this.extend1 = extend1; &#125; public String getCategory() &#123; return category; &#125; public void setCategory(String category) &#123; this.category = category; &#125; &#125; 事件日志 Bean 之商品详情页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.bean;/*** 商品详情*/public class AppNewsDetail &#123;private String entry;//页面入口来源：应用首页=1、 push=2、详情页相关推荐=3private String action;//动作：开始加载=1，加载成功=2（pv），加载失败=3, 退出页面=4private String goodsid;//商品 ID（服务端下发的 ID）private String showtype;//商品样式： 0、无图 1、一张大图 2、两张图 3、三张小图 4、一张小图 5、一张大图两张小图 来源于详情页相关推荐的商品，上报样式都为 0（因为都是左文右图）private String news_staytime;//页面停留时长：从商品开始加载时开始计算，到用户关闭页面所用的时间。若中途用跳转到其它页面了，则暂停计时，待回到详情页时恢复计时。或中途划出的时间超过 10 分钟，则本次计时作废，不上报本次数据。如未加载成功退出，则报空。private String loading_time;//加载时长：计算页面开始加载到接口返回数据的时间（开始加载报 0，加载成功或加载失败才上报时间）private String type1;//加载失败码：把加载失败状态码报回来（报空为加载成功，没有失败）private String category;//分类 ID（服务端定义的分类 ID）public String getEntry() &#123;return entry;&#125;public void setEntry(String entry) &#123;this.entry = entry;&#125;public String getAction() &#123;return action;&#125;public void setAction(String action) &#123;this.action = action;&#125;public String getGoodsid() &#123;return goodsid;&#125;public void setGoodsid(String goodsid) &#123;this.goodsid = goodsid;&#125;public String getShowtype() &#123;return showtype;&#125;public void setShowtype(String showtype) &#123;this.showtype = showtype;&#125;public String getNews_staytime() &#123;return news_staytime;&#125;public void setNews_staytime(String news_staytime) &#123;this.news_staytime = news_staytime;&#125;public String getLoading_time() &#123;return loading_time;&#125;public void setLoading_time(String loading_time) &#123;this.loading_time = loading_time;&#125;public String getType1() &#123;return type1;&#125;public void setType1(String type1) &#123;this.type1 = type1;&#125;public String getCategory() &#123;return category;&#125;public void setCategory(String category) &#123;this.category = category;&#125;&#125; 事件日志 Bean 之商品列表页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.atguigu.bean;/*** 商品列表*/public class AppLoading &#123;private String action;//动作：开始加载=1，加载成功=2，加载失败=3private String loading_time;//加载时长：计算下拉开始到接口返回数据的时间，（开始加载报 0，加载成功或加载失败才上报时间）private String loading_way;//加载类型： 1-读取缓存， 2-从接口拉新数据 （加载成功才上报加载类型）private String extend1;//扩展字段 Extend1private String extend2;//扩展字段 Extend2private String type;//加载类型：自动加载=1，用户下拽加载=2，底部加载=3（底部条触发点击底部提示条/点击返回顶部加载）private String type1;//加载失败码：把加载失败状态码报回来（报空为加载成功，没有失败）public String getAction() &#123;return action;&#125;public void setAction(String action) &#123;this.action = action;&#125;public String getLoading_time() &#123;return loading_time;&#125;public void setLoading_time(String loading_time) &#123;this.loading_time = loading_time;&#125;public String getLoading_way() &#123;return loading_way;&#125;public void setLoading_way(String loading_way) &#123;this.loading_way = loading_way;&#125;public String getExtend1() &#123;return extend1;&#125;public void setExtend1(String extend1) &#123;this.extend1 = extend1;&#125;public String getExtend2() &#123;return extend2;&#125;public void setExtend2(String extend2) &#123;this.extend2 = extend2;&#125;public String getType() &#123;return type;&#125;public void setType(String type) &#123;this.type = type;&#125;public String getType1() &#123;return type1;&#125;public void setType1(String type1) &#123;this.type1 = type1;&#125;&#125; 事件日志 Bean 之购物车123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.bean;/*** 购物车*/public class AppCart &#123;int itemid;int action; // 1 添加产品进购物车 2 调整购物车数量int changeNum; // 数量变化int beforeNum; // 变化前数量int afterNum; // 变化后数量Double price; // 加入购物车时的单价public int getItemid() &#123;return itemid;&#125;public void setItemid(int itemid) &#123;this.itemid = itemid;&#125;public int getAction() &#123;return action;&#125;public void setAction(int action) &#123;this.action = action;&#125;public int getChangeNum() &#123;return changeNum;&#125;public void setChangeNum(int changeNum) &#123;this.changeNum = changeNum;&#125;public int getBeforeNum() &#123;return beforeNum;&#125;public void setBeforeNum(int beforeNum) &#123;this.beforeNum = beforeNum;&#125;public int getAfterNum() &#123;return afterNum;&#125;public void setAfterNum(int afterNum) &#123;this.afterNum = afterNum;&#125;public Double getPrice() &#123;return price;&#125;public void setPrice(Double price) &#123;this.price = price;&#125;&#125; 事件日志 Bean 之广告123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.atguigu.bean;&#x2F;*** 广告*&#x2F;public class AppAd &#123;private String entry;&#x2F;&#x2F;入口：商品列表页&#x3D;1 应用首页&#x3D;2 商品详情页&#x3D;3private String action;&#x2F;&#x2F;动作：请求广告&#x3D;1 取缓存广告&#x3D;2 广告位展示&#x3D;3 广告展示&#x3D;4 广告点击&#x3D;5private String content;&#x2F;&#x2F;状态：成功&#x3D;1 失败&#x3D;2private String detail;&#x2F;&#x2F;失败码（没有则上报空）private String source;&#x2F;&#x2F;广告来源:admob&#x3D;1 facebook&#x3D;2 ADX（百度） &#x3D;3 VK（俄罗斯） &#x3D;4private String behavior;&#x2F;&#x2F;用户行为： 主动获取广告&#x3D;1 被动获取广告&#x3D;2private String newstype;&#x2F;&#x2F;Type: 1- 图文 2-图集 3-段子 4-GIF 5-视频 6-调查7-纯文 8-视频+图文 9-GIF+图文 0-其他private String show_style;&#x2F;&#x2F;内容样式：无图(纯文字)&#x3D;6 一张大图&#x3D;1 三站小图+文&#x3D;4 一张小图&#x3D;2 一张大图两张小图+文&#x3D;3 图集+文 &#x3D; 5&#x2F;&#x2F;一张大图+文&#x3D;11 GIF 大图+文&#x3D;12 视频(大图)+文 &#x3D; 13&#x2F;&#x2F;来源于详情页相关推荐的商品，上报样式都为 0（因为都是左文右图）public String getEntry() &#123;return entry;&#125;public void setEntry(String entry) &#123;this.entry &#x3D; entry;&#125;public String getAction() &#123;return action;&#125;public void setAction(String action) &#123;this.action &#x3D; action;&#125;public String getContent() &#123;return content;&#125;public void setContent(String content) &#123;this.content &#x3D; content;&#125;public String getDetail() &#123;return detail;&#125;public void setDetail(String detail) &#123;this.detail &#x3D; detail;&#125;public String getSource() &#123;return source;&#125;public void setSource(String source) &#123;this.source &#x3D; source;&#125;public String getBehavior() &#123;return behavior;&#125;public void setBehavior(String behavior) &#123;this.behavior &#x3D; behavior;&#125; public String getNewstype() &#123;return newstype;&#125;public void setNewstype(String newstype) &#123;this.newstype &#x3D; newstype;&#125;public String getShow_style() &#123;return show_style;&#125;public void setShow_style(String show_style) &#123;this.show_style &#x3D; show_style;&#125;&#125; 事件日志 Bean 之消息通知1234567891011121314151617181920212223242526272829303132333435package com.atguigu.bean;/*** 消息通知日志*/public class AppNotification &#123;private String action;//动作：通知产生=1，通知弹出=2，通知点击=3，常驻通知展示（不重复上报，一天之内只报一次） =4private String type;//通知 id：预警通知=1，天气预报（早=2，晚=3），常驻=4private String ap_time;//客户端弹出时间private String content;//备用字段public String getAction() &#123;return action;&#125;public void setAction(String action) &#123;this.action = action;&#125;public String getType() &#123;return type;&#125;public void setType(String type) &#123;this.type = type;&#125;public String getAp_time() &#123;return ap_time;&#125;public void setAp_time(String ap_time) &#123;this.ap_time = ap_time;&#125;public String getContent() &#123;return content;&#125;public void setContent(String content) &#123;this.content = content;&#125;&#125; 事件日志 Bean 之用户评论1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.bean;&#x2F;*** 评论*&#x2F;public class AppComment &#123;private int comment_id;&#x2F;&#x2F;评论表private int userid;&#x2F;&#x2F;用户 idprivate int p_comment_id;&#x2F;&#x2F;父级评论 id(为 0 则是一级评论,不为 0 则是回复)private String content;&#x2F;&#x2F;评论内容private String addtime;&#x2F;&#x2F;创建时间private int other_id;&#x2F;&#x2F;评论的相关 idprivate int praise_count;&#x2F;&#x2F;点赞数量private int reply_count;&#x2F;&#x2F;回复数量public int getComment_id() &#123;return comment_id;&#125;public void setComment_id(int comment_id) &#123;this.comment_id &#x3D; comment_id;&#125;public int getUserid() &#123;return userid;&#125;public void setUserid(int userid) &#123;this.userid &#x3D; userid;&#125;public int getP_comment_id() &#123;return p_comment_id;&#125;public void setP_comment_id(int p_comment_id) &#123;this.p_comment_id &#x3D; p_comment_id;&#125;public String getContent() &#123;return content;&#125;public void setContent(String content) &#123;this.content &#x3D; content;&#125;public String getAddtime() &#123;return addtime;&#125;public void setAddtime(String addtime) &#123;this.addtime &#x3D; addtime;&#125;public int getOther_id() &#123;return other_id;&#125;public void setOther_id(int other_id) &#123;this.other_id &#x3D; other_id;&#125;public int getPraise_count() &#123;return praise_count;&#125;public void setPraise_count(int praise_count) &#123;this.praise_count &#x3D; praise_count;&#125;public int getReply_count() &#123;return reply_count;&#125;public void setReply_count(int reply_count) &#123;this.reply_count &#x3D; reply_count;&#125;&#125; 事件日志 Bean 之用户收藏12345678910111213141516171819202122232425262728293031323334package com.atguigu.bean;/*** 收藏*/public class AppFavorites &#123;private int id;//主键private int course_id;//商品 idprivate int userid;//用户 IDprivate String add_time;//创建时间public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id = id;&#125;public int getCourse_id() &#123;return course_id;&#125;public void setCourse_id(int course_id) &#123;this.course_id = course_id;&#125;public int getUserid() &#123;return userid;&#125;public void setUserid(int userid) &#123;this.userid = userid;&#125;public String getAdd_time() &#123;return add_time;&#125;public void setAdd_time(String add_time) &#123;this.add_time = add_time;&#125;&#125; 事件日志 Bean 之用户点赞1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.bean;/*** 点赞*/public class AppPraise &#123;private int id; //主键 idprivate int userid;//用户 idprivate int target_id;//点赞的对象 idprivate int type;//点赞类型 1 问答点赞 2 问答评论点赞 3 文章点赞数 4 评论点赞private String add_time;//添加时间public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id = id;&#125;public int getUserid() &#123;return userid;&#125;public void setUserid(int userid) &#123;this.userid = userid;&#125;public int getTarget_id() &#123;return target_id;&#125;public void setTarget_id(int target_id) &#123;this.target_id = target_id;&#125;public int getType() &#123;return type;&#125;public void setType(int type) &#123;this.type = type;&#125;public String getAdd_time() &#123;return add_time;&#125;public void setAdd_time(String add_time) &#123;this.add_time = add_time;&#125;&#125; 主函数 在 AppMain 类中添加如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598package com.atguigu.appclient;import java.io.UnsupportedEncodingException;import java.util.Random;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.atguigu.bean.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/*** 日志行为数据模拟*/public class AppMain &#123;private final static Logger logger =LoggerFactory.getLogger(AppMain.class);private static Random rand = new Random();// 设备 idprivate static int s_mid = 0;// 用户 idprivate static int s_uid = 0;// 商品 idprivate static int s_goodsid = 0;public static void main(String[] args) &#123;// 参数一：控制发送每条的延时时间，默认是 0Long delay = args.length &gt; 0 ? Long.parseLong(args[0]) : 0L;// 参数二：循环遍历次数int loop_len = args.length &gt; 1 ? Integer.parseInt(args[1]) : 1000;// 生成数据generateLog(delay, loop_len);&#125;private static void generateLog(Long delay, int loop_len) &#123;for (int i = 0; i &lt; loop_len; i++) &#123;JSONObject json = new JSONObject();json.put(\"ap\", \"app\");json.put(\"cm\", generateComFields());JSONArray eventsArray = new JSONArray();// 启动日志eventsArray.add(generateStart());// 事件日志// 商品曝光if (rand.nextBoolean()) &#123;eventsArray.add(generateDisplay());&#125;// 商品详情页if (rand.nextBoolean()) &#123;eventsArray.add(generateNewsDetail());&#125;// 商品列表页if (rand.nextBoolean()) &#123;eventsArray.add(generateNewList());&#125;// 购物车if (rand.nextBoolean()) &#123;eventsArray.add(generateCart());&#125;// 广告if (rand.nextBoolean()) &#123;eventsArray.add(generateAd());&#125;// 消息通知if (rand.nextBoolean()) &#123;eventsArray.add(generateNotification());&#125;//故障日志if (rand.nextBoolean()) &#123;eventsArray.add(generateError());&#125;// 用户评论if (rand.nextBoolean()) &#123;eventsArray.add(generateComment());&#125;// 用户收藏if (rand.nextBoolean()) &#123;eventsArray.add(generateFavorites());&#125;// 用户点赞if (rand.nextBoolean()) &#123;eventsArray.add(generatePraise());&#125;json.put(\"et\", eventsArray);//时间long millis2 = System.currentTimeMillis();//控制台打印logger.info(millis2 + \"|\" + json.toJSONString());// 延迟try &#123;Thread.sleep(delay);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;/*** 公共字段设置*/private static JSONObject generateComFields() &#123;AppBase appBase = new AppBase();//设备 idappBase.setMid(s_mid + \"\");s_mid++;// 用户 idappBase.setUid(s_uid + \"\");s_uid++;// 程序版本号 5,6 等appBase.setVc(\"\" + rand.nextInt(20));//程序版本名 v1.1.1appBase.setVn(\"1.\" + rand.nextInt(4) + \".\" + rand.nextInt(10));// 安卓系统版本appBase.setOs(\"8.\" + rand.nextInt(3) + \".\" + rand.nextInt(10));// 语言 es,en,ptint flag = rand.nextInt(3);switch (flag) &#123;case (0):appBase.setL(\"es\");break;case (1):appBase.setL(\"en\");break;case (2):appBase.setL(\"pt\");break;&#125;// 渠道号 从哪个渠道来的appBase.setSr(getRandomChar(1));// 区域flag = rand.nextInt(2);switch (flag) &#123;case 0:appBase.setAr(\"BR\");case 1:appBase.setAr(\"MX\");&#125;// 手机品牌 ba ,手机型号 md，就取 2 位数字了flag = rand.nextInt(3);switch (flag) &#123;case 0:appBase.setBa(\"Sumsung\");appBase.setMd(\"sumsung-\" + rand.nextInt(20));break;case 1:appBase.setBa(\"Huawei\");appBase.setMd(\"Huawei-\" + rand.nextInt(20));break;case 2:appBase.setBa(\"HTC\");appBase.setMd(\"HTC-\" + rand.nextInt(20));break;&#125;// 嵌入 sdk 的版本appBase.setSv(\"V2.\" + rand.nextInt(10) + \".\" + rand.nextInt(10));// gmailappBase.setG(getRandomCharAndNumr(8) + \"@gmail.com\");// 屏幕宽高 hwflag = rand.nextInt(4);switch (flag) &#123;case 0:appBase.setHw(\"640*960\");break;case 1:appBase.setHw(\"640*1136\");break;case 2:appBase.setHw(\"750*1134\");break;case 3:appBase.setHw(\"1080*1920\");break;&#125;// 客户端产生日志时间long millis = System.currentTimeMillis();appBase.setT(\"\" + (millis - rand.nextInt(99999999)));// 手机网络模式 3G,4G,WIFIflag = rand.nextInt(3);switch (flag) &#123;case 0:appBase.setNw(\"3G\");break;case 1:appBase.setNw(\"4G\");break;case 2:appBase.setNw(\"WIFI\");break;&#125;// 拉丁美洲 西经 34°46′至西经 117°09；北纬 32°42′至南纬 53°54′// 经度appBase.setLn((-34 - rand.nextInt(83) - rand.nextInt(60) / 10.0) +\"\");// 纬度appBase.setLa((32 - rand.nextInt(85) - rand.nextInt(60) / 10.0) +\"\");return (JSONObject) JSON.toJSON(appBase);&#125;/*** 商品展示事件*/private static JSONObject generateDisplay() &#123;AppDisplay appDisplay = new AppDisplay();boolean boolFlag = rand.nextInt(10) &lt; 7;// 动作：曝光商品=1，点击商品=2，if (boolFlag) &#123;appDisplay.setAction(\"1\");&#125; else &#123;appDisplay.setAction(\"2\");&#125;// 商品 idString goodsId = s_goodsid + \"\";s_goodsid++;appDisplay.setGoodsid(goodsId);// 顺序 设置成 6 条吧int flag = rand.nextInt(6);appDisplay.setPlace(\"\" + flag);// 曝光类型flag = 1 + rand.nextInt(2);appDisplay.setExtend1(\"\" + flag);// 分类flag = 1 + rand.nextInt(100);appDisplay.setCategory(\"\" + flag);JSONObject jsonObject = (JSONObject) JSON.toJSON(appDisplay);return packEventJson(\"display\", jsonObject);&#125;/*** 商品详情页*/private static JSONObject generateNewsDetail() &#123;AppNewsDetail appNewsDetail = new AppNewsDetail();// 页面入口来源int flag = 1 + rand.nextInt(3);appNewsDetail.setEntry(flag + \"\");// 动作appNewsDetail.setAction(\"\" + (rand.nextInt(4) + 1));// 商品 idappNewsDetail.setGoodsid(s_goodsid + \"\");// 商品来源类型flag = 1 + rand.nextInt(3);appNewsDetail.setShowtype(flag + \"\");// 商品样式flag = rand.nextInt(6);appNewsDetail.setShowtype(\"\" + flag);// 页面停留时长flag = rand.nextInt(10) * rand.nextInt(7);appNewsDetail.setNews_staytime(flag + \"\");// 加载时长flag = rand.nextInt(10) * rand.nextInt(7);appNewsDetail.setLoading_time(flag + \"\");// 加载失败码flag = rand.nextInt(10);switch (flag) &#123;case 1:appNewsDetail.setType1(\"102\");break;case 2:appNewsDetail.setType1(\"201\");break;case 3:appNewsDetail.setType1(\"325\");break;case 4:appNewsDetail.setType1(\"433\");break;case 5:appNewsDetail.setType1(\"542\");break;default:appNewsDetail.setType1(\"\");break;&#125;// 分类flag = 1 + rand.nextInt(100);appNewsDetail.setCategory(\"\" + flag);JSONObject eventJson = (JSONObject) JSON.toJSON(appNewsDetail);return packEventJson(\"newsdetail\", eventJson);&#125;/*** 商品列表*/private static JSONObject generateNewList() &#123;AppLoading appLoading = new AppLoading();// 动作int flag = rand.nextInt(3) + 1;appLoading.setAction(flag + \"\");// 加载时长flag = rand.nextInt(10) * rand.nextInt(7);appLoading.setLoading_time(flag + \"\");// 失败码flag = rand.nextInt(10);switch (flag) &#123;case 1:appLoading.setType1(\"102\");break;case 2:appLoading.setType1(\"201\");break;case 3:appLoading.setType1(\"325\");break;case 4:appLoading.setType1(\"433\");break;case 5:appLoading.setType1(\"542\");break;default:appLoading.setType1(\"\");break;&#125;// 页面 加载类型flag = 1 + rand.nextInt(2);appLoading.setLoading_way(\"\" + flag);// 扩展字段 1appLoading.setExtend1(\"\");// 扩展字段 2appLoading.setExtend2(\"\");// 用户加载类型flag = 1 + rand.nextInt(3);appLoading.setType(\"\" + flag);JSONObject jsonObject = (JSONObject) JSON.toJSON(appLoading);return packEventJson(\"loading\", jsonObject);&#125;/*** 购物车*/static public JSONObject generateCart() &#123;AppCart appItemCart = new AppCart();appItemCart.setItemid(s_mid);appItemCart.setBeforeNum(1 + rand.nextInt(3));appItemCart.setAction(1 + rand.nextInt(2));if (appItemCart.getAction() == 2) &#123;int changNum = (-1) + rand.nextInt(3);changNum = (changNum == 0 ? 1 : changNum);appItemCart.setChangeNum(changNum);appItemCart.setAfterNum(appItemCart.getBeforeNum() +appItemCart.getChangeNum());&#125;JSONObject jsonObject = (JSONObject) JSON.toJSON(appItemCart);return packEventJson(\"favorites\", jsonObject);&#125;/*** 广告相关字段*/private static JSONObject generateAd() &#123;AppAd appAd = new AppAd();// 入口int flag = rand.nextInt(3) + 1;appAd.setEntry(flag + \"\");// 动作flag = rand.nextInt(5) + 1;appAd.setAction(flag + \"\");// 状态flag = rand.nextInt(10) &gt; 6 ? 2 : 1;appAd.setContent(flag + \"\");// 失败码flag = rand.nextInt(10);switch (flag) &#123;case 1:appAd.setDetail(\"102\");break;case 2:appAd.setDetail(\"201\");break;case 3:appAd.setDetail(\"325\");break;case 4:appAd.setDetail(\"433\");break;case 5:appAd.setDetail(\"542\");break;default:appAd.setDetail(\"\");break;&#125;// 广告来源flag = rand.nextInt(4) + 1;appAd.setSource(flag + \"\");// 用户行为flag = rand.nextInt(2) + 1;appAd.setBehavior(flag + \"\");// 商品类型flag = rand.nextInt(10);appAd.setNewstype(\"\" + flag);// 展示样式flag = rand.nextInt(6);appAd.setShow_style(\"\" + flag);JSONObject jsonObject = (JSONObject) JSON.toJSON(appAd);return packEventJson(\"ad\", jsonObject);&#125;/*** 启动日志*/static JSONObject generateStart() &#123;AppStart appStart = new AppStart();// 入口int flag = rand.nextInt(5) + 1;appStart.setEntry(flag + \"\");// 开屏广告类型flag = rand.nextInt(2) + 1;appStart.setOpen_ad_type(flag + \"\");// 状态flag = rand.nextInt(10) &gt; 8 ? 2 : 1;appStart.setAction(flag + \"\");// 加载时长appStart.setLoading_time(rand.nextInt(20) + \"\");// 失败码flag = rand.nextInt(10);switch (flag) &#123;case 1:appStart.setDetail(\"102\");break;case 2:appStart.setDetail(\"201\");break;case 3:appStart.setDetail(\"325\");break;case 4:appStart.setDetail(\"433\");break;case 5:appStart.setDetail(\"542\");break;default:appStart.setDetail(\"\");break;&#125;JSONObject jsonObject = (JSONObject) JSON.toJSON(appStart);return packEventJson(\"start\", jsonObject);&#125;/*** 消息通知*/private static JSONObject generateNotification() &#123;AppNotification appNotification = new AppNotification();int flag = rand.nextInt(4) + 1;// 动作appNotification.setAction(flag + \"\");// 通知 idflag = rand.nextInt(4) + 1;appNotification.setType(flag + \"\");// 客户端弹时间appNotification.setAp_time((System.currentTimeMillis() -rand.nextInt(99999999)) + \"\");// 备用字段appNotification.setContent(\"\");JSONObject jsonObject = (JSONObject) JSON.toJSON(appNotification);return packEventJson(\"notification\", jsonObject);&#125;/*** 错误日志数据*/private static JSONObject generateError() &#123;AppError appErrorLog = new AppError();String[] errorBriefs = &#123;\"atcn.lift.dfdf.web.AbstractBaseController.validInbound(AbstractBaseController.java:72)\", \"atcn.lift.appIn.control.CommandUtil.getInfo(CommandUtil.java:67)\"&#125;;//错误摘要String[] errorDetails = &#123;\"java.lang.NullPointerException\\\\n \" +\"atcn.lift.appIn.web.AbstractBaseController.validInbound(AbstractBaseController.java:72)\\\\n \" + \"atcn.lift.dfdf.web.AbstractBaseController.validInbound\", \"atcn.lift.dfdfdf.control.CommandUtil.getInfo(CommandUtil.java:67)\\\\n \" +\"atsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\\\n\" + \" atjava.lang.reflect.Method.invoke(Method.java:606)\\\\n\"&#125;; //错误详情//错误摘要appErrorLog.setErrorBrief(errorBriefs[rand.nextInt(errorBriefs.length)]);//错误详情appErrorLog.setErrorDetail(errorDetails[rand.nextInt(errorDetails.length)]);JSONObject jsonObject = (JSONObject) JSON.toJSON(appErrorLog);return packEventJson(\"error\", jsonObject);&#125;/*** 为各个事件类型的公共字段（时间、事件类型、 Json 数据）拼接*/private static JSONObject packEventJson(String eventName, JSONObjectjsonObject) &#123;JSONObject eventJson = new JSONObject();eventJson.put(\"ett\", (System.currentTimeMillis() -rand.nextInt(99999999)) + \"\");eventJson.put(\"en\", eventName);eventJson.put(\"kv\", jsonObject);return eventJson;&#125;/*** 获取随机字母组合** @param length 字符串长度*/private static String getRandomChar(Integer length) &#123;StringBuilder str = new StringBuilder();Random random = new Random();for (int i = 0; i &lt; length; i++) &#123;// 字符串str.append((char) (65 + random.nextInt(26)));// 取得大写字母&#125;return str.toString();&#125;/*** 获取随机字母数字组合** @param length 字符串长度*/private static String getRandomCharAndNumr(Integer length) &#123;StringBuilder str = new StringBuilder();Random random = new Random();for (int i = 0; i &lt; length; i++) &#123;boolean b = random.nextBoolean();if (b) &#123; // 字符串// int choice = random.nextBoolean() ? 65 : 97; 取得 65 大写字母还是 97 小写字母str.append((char) (65 + random.nextInt(26)));// 取得大写字母&#125; else &#123; // 数字str.append(String.valueOf(random.nextInt(10)));&#125;&#125;return str.toString();&#125;/*** 收藏*/private static JSONObject generateFavorites() &#123;AppFavorites favorites = new AppFavorites();favorites.setCourse_id(rand.nextInt(10));favorites.setUserid(rand.nextInt(10));favorites.setAdd_time((System.currentTimeMillis() -rand.nextInt(99999999)) + \"\");JSONObject jsonObject = (JSONObject) JSON.toJSON(favorites);return packEventJson(\"favorites\", jsonObject);&#125;/*** 点赞*/private static JSONObject generatePraise() &#123;AppPraise praise = new AppPraise();praise.setId(rand.nextInt(10));praise.setUserid(rand.nextInt(10));praise.setTarget_id(rand.nextInt(10));praise.setType(rand.nextInt(4) + 1);praise.setAdd_time((System.currentTimeMillis() -rand.nextInt(99999999)) + \"\");JSONObject jsonObject = (JSONObject) JSON.toJSON(praise);return packEventJson(\"praise\", jsonObject);&#125;/*** 评论*/private static JSONObject generateComment() &#123;AppComment comment = new AppComment();comment.setComment_id(rand.nextInt(10));comment.setUserid(rand.nextInt(10));comment.setP_comment_id(rand.nextInt(5));comment.setContent(getCONTENT());comment.setAddtime((System.currentTimeMillis() -rand.nextInt(99999999)) + \"\");comment.setOther_id(rand.nextInt(10));comment.setPraise_count(rand.nextInt(1000));comment.setReply_count(rand.nextInt(200));JSONObject jsonObject = (JSONObject) JSON.toJSON(comment);return packEventJson(\"comment\", jsonObject);&#125;/*** 生成单个汉字*/private static char getRandomChar() &#123;String str = \"\";int hightPos; //int lowPos;Random random = new Random();//随机生成汉子的两个字节hightPos = (176 + Math.abs(random.nextInt(39)));lowPos = (161 + Math.abs(random.nextInt(93)));byte[] b = new byte[2];b[0] = (Integer.valueOf(hightPos)).byteValue();b[1] = (Integer.valueOf(lowPos)).byteValue();try &#123;str = new String(b, \"GBK\");&#125; catch (UnsupportedEncodingException e) &#123;e.printStackTrace();System.out.println(\"错误\");&#125;return str.charAt(0);&#125;/*** 拼接成多个汉字*/private static String getCONTENT() &#123;StringBuilder str = new StringBuilder();for (int i = 0; i &lt; rand.nextInt(100); i++) &#123;str.append(getRandomChar());&#125;return str.toString();&#125;&#125; 配置日志打印（Logback）Logback 主要用于在磁盘和控制台打印日志。 Logback 具体使用如下：1）在 resources 文件夹下创建 logback.xml 文件。2）在 logback.xml 文件中填写如下配配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"false\"&gt;&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径 --&gt;&lt;property name=\"LOG_HOME\" value=\"/opt/module/logs/\" /&gt;&lt;!-- 控制台输出 --&gt;&lt;appender name=\"STDOUT\"class=\"ch.qos.logback.core.ConsoleAppender\"&gt;&lt;encoderclass=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt;&lt;!--格式化输出： %d 表示日期， %thread 表示线程名， %-5level：级别从左显示 5 个字符宽度%msg：日志消息， %n 是换行符 --&gt;&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125;- %msg%n&lt;/pattern&gt;&lt;/encoder&gt;&lt;/appender&gt;&lt;!-- 按照每天生成日志文件。存储事件日志 --&gt;&lt;appender name=\"FILE\"class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt;&lt;!-- &lt;File&gt;$&#123;LOG_HOME&#125;/app.log&lt;/File&gt;设置日志不超过$&#123;log.max.size&#125;时的保存路径，注意，如果是 web 项目会保存到 Tomcat 的 bin 目录 下 --&gt;&lt;rollingPolicyclass=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt;&lt;!--日志文件输出的文件名 --&gt;&lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;/app-%d&#123;yyyy-MM\u0002dd&#125;.log&lt;/FileNamePattern&gt;&lt;!--日志文件保留天数 --&gt;&lt;MaxHistory&gt;30&lt;/MaxHistory&gt;&lt;/rollingPolicy&gt; &lt;encoderclass=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt;&lt;pattern&gt;%msg%n&lt;/pattern&gt;&lt;/encoder&gt;&lt;!--日志文件最大的大小 --&gt;&lt;triggeringPolicyclass=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt;&lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;&lt;/triggeringPolicy&gt;&lt;/appender&gt;&lt;!--异步打印日志--&gt;&lt;appender name =\"ASYNC_FILE\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt;&lt;!-- 不丢失日志.默认的,如果队列的 80%已满,则会丢弃 TRACT、 DEBUG、 INFO 级别的日志 --&gt;&lt;discardingThreshold &gt;0&lt;/discardingThreshold&gt;&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为 256 --&gt;&lt;queueSize&gt;512&lt;/queueSize&gt;&lt;!-- 添加附加的 appender,最多只能添加一个 --&gt;&lt;appender-ref ref = \"FILE\"/&gt;&lt;/appender&gt;&lt;!-- 日志输出级别 --&gt;&lt;root level=\"INFO\"&gt;&lt;appender-ref ref=\"STDOUT\" /&gt;&lt;appender-ref ref=\"ASYNC_FILE\" /&gt;&lt;appender-ref ref=\"error\" /&gt;&lt;/root&gt;&lt;/configuration&gt; 打包1）采用 Maven 对程序打包 数据采集模块日志生成1）集群规划 2） 打包好的 log-collector-1.0-SNAPSHOT-jar-with-dependencies.jar 程序到hadoop102 的/opt/module/目录下，并执行如下命令 java -jar log-collector-1.0-SNAPSHOT-jar-with-dependencies.jar &gt; /dev/null 2&gt;&amp;1 &amp; 3）然后进入到/opt/module/logs 目录，观察日志是否写入成功 Flume 安装及使用1） Flume 官网地址： http://flume.apache.org/2）文档查看地址： http://flume.apache.org/FlumeUserGuide.html3）下载地址： http://archive.apache.org/dist/flume/ Flume 简介Flume 是 Cloudera 提供的一个高可用的，高可靠的， 分布式的海量日志采集、聚合和传输的系统。 Flume 基于流式架构，灵活简单。 1） Source主要负责采集工作，采用 TailDir 组件用于监控文件或文件夹的变化。2） Channel扮演数据管道的角色，对数据进行缓冲。采用非持久化的 Memory 类型。3） Sink把 Channel 中的数据输出到外部环境中，支持多种数据接口（ HDFS、 Kafka 等），此次案例中我们的最终目标是数据到阿里云的数据总线中（ DataHub），调试阶段可以先输出到控制台中。 Flume 安装集群规划 1）将 apache-flume-1.7.0-bin.tar.gz 上传到 hadoop102 的/opt/software 目录下2）解压 apache-flume-1.7.0-bin.tar.gz 到/opt/module/目录下[atguigu@hadoop102 software]$ tar -zxf apache-flume-1.7.0-bin.tar.gz -C /opt/module/3） 修改 apache-flume-1.7.0-bin 的名称为 flume[atguigu@hadoop102 module]$ mv apache-flume-1.7.0-bin flume4）将 flume/conf 下的 flume-env.sh.template 文件修改为 flume-env.sh，并配置 flume-env.sh 文件 [atguigu@hadoop102 conf]$ mv flume-env.sh.template flume-env.sh[atguigu@hadoop102 conf]$ vi flume-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144 Flume 配置1）在/opt/module/flume/conf 中添加文件 file-flume-log.conf，该文件是一个 Flume 作业的核心文件，咱们上述的 Source、 Channel、 Sink 都是通过这个配置文件来实现的。 [atguigu@hadoop102 conf]$ vim file-flume-log.conf添加如下内容 定义组件名称a1.sources = r1a1.sinks = k1a1.channels = c1###source 部分a1.sources.r1.type = TAILDIR#记录偏移量实现断点续传a1.sources.r1.positionFile =/opt/module/flume/test/taildir_position.jsona1.sources.r1.channels = c1a1.sources.r1.filegroups=f1a1.sources.r1.filegroups.f1=/opt/module/logs/app.+a1.sources.r1.fileHeader = true###channel 部分a1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 1000###sink 部分 先输出到控制台中a1.sinks.k1.type = logger #把 source 和 sink 绑定到 channel 中 a1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动 Flume 进程[atguigu@hadoop102 flume]$ /opt/module/flume/bin/flume-ng agent -n a1 -c /opt/module/flume/conf/ -f/opt/module/flume/conf/file-flume-log.conf -Dflume.root.logger=info,console 说明 参数选项 含义 flume-ng agent 启动 Flume 程序 -n 任务名称，必须和配置文件中的前缀一致。 -c Flume 基本配置文件位置 -f Flume 任务配置文件位置 -Dflume.root.logger=info,console 打印控制台 验证，启动 Flume 的同时，运行日志生成程序，观察 Flume 控制台是否滚动打印日志。 DataHub 安装及使用DataHub 简介Flume 部分已经可以输出后，咱们开始搭建真正需要输出的目的地—DataHub，即阿里云数据总线服务。通俗来说这个 DataHub 类似于传统大数据解决方案中 Kafka 的角色，提供了一个数据 队列功能。 对于离线计算， DataHub 除了供了一个缓冲的队列作用。 同时由于 DataHub 提供了各种与其他阿里云上下游产品的对接功能，所以 DataHub 又扮演了一个数据的分发枢纽工作。 1） DataHub 输入组件包括Flume：主流的开源日志采集框架DTS： 类似 Canal， 日志实时监控采集框架Logstash： 也是日志采集框架，通常和 Elasticsearch、 Kibana 集合使用Fluentd： Fluentd 是一个实时开源的数据收集器OGG： 实时监控 Oracle 中数据变化Java sdk：支持 JavaAPI 方式访问2） DataHub 输出组件包括RDS：类似与传统 MySQL 数据库AnalyticDB： 面向分析型的分布式数据库MaxCompute：离线分析框架Elasticsearch：数据分析，倒排索引StreamCompute：实时分析框架TableSotre：类似于 Redis， KV 形式存储数据 OSS：类似于 HDFS， 存储图片、视频 创建 DataHub 与 Topic阿里云 DataHub 控制台入口： https://datahub.console.aliyun.com/datahub1） 进入到 DataHub 控制台 2） 点击创建 Project 3）点击查看，准备创建主题 4）点击创建 Topic 5）配置 Topic 详情 说明： 选择参数 含义 Topic 类型 Tuple 为结构化数据， Blob 是二进制数据。 Schema Tuple 类型的字段名 Shard 数量 决定了队列吞吐量，每个 Shard 支持 1MB/s 的写入能力 生命周期 数据在队列中的最长存活时间 Flume 推送数据到 DataHubFlume-DataHub 插件安装Flume 默认是不支持 DataHub 的，所以要给 Flume 安装 DataHub 的 Sink 插件 插件名称: aliyun-flume-datahub-sink-2.0.2.tar.gz 1）首先在 Flume 安装目录建立插件文件夹 mkdir plugins.d 2 ） 利 用 SecureCRT 工 具 把 aliyun-flume-datahub-sink-2.0.2.tar.gz 拷 贝 到 该/opt/module/flume/plugins.d 目录下，并原地解压缩 ls tar -zxvf aliyun-flume-datahub\u0002sink-2.0.2.tar.gz Flume 配置文件修改vim /opt/module/flume/conf/file\u0002flume-datahub.conf #定义组件名称 a1.sources = r1a1.sinks = k1a1.channels = c1 source 部分a1.sources.r1.type = TAILDIRa1.sources.r1.positionFile =/opt/module/flume/test/taildir_position.jsona1.sources.r1.channels = c1a1.sources.r1.filegroups = f1a1.sources.r1.filegroups.f1 = /opt/module/logs/app.+a1.sources.r1.fileHeader = true channel 部分a1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 1000 #sink 部分 a1.sinks.k1.type = com.aliyun.datahub.flume.sink.DatahubSinka1.sinks.k1.datahub.accessID = LTAI4FiU71dZAL17SdLBa6Nta1.sinks.k1.datahub.accessKey = 63YzSmqMOSjDR5A2ZXEzFLM2tREY6ma1.sinks.k1.datahub.endPoint = http://xxxxxinc.coma1.sinks.k1.datahub.project = gmall_datahuba1.sinks.k1.datahub.topic = base_loga1.sinks.k1.batchSize = 100a1.sinks.k1.serializer = DELIMITEDa1.sinks.k1.serializer.delimiter = “\\u007C”a1.sinks.k1.serializer.fieldnames = event_time,log_stringa1.sinks.k1.serializer.charset = UTF-8a1.sinks.k1.shard.number = 1a1.sinks.k1.shard.maxTimeOut = 60 #把 source 和 sink 绑定到 channel 中 a1.sources.r1.channels = c1a1.sinks.k1.channel = c1 说明： 选择参数 含义 type 必须是： com.aliyun.datahub.flume.sink.DatahubSink datahub.accessID accessID 下面小节会介绍 datahub.accessKey accessKey datahub.endPoint 不同的地区有不同的接入点，参考 https://help.aliyun.com/document_detail/47442.html project datahub 中创建的 project 名 topic datahub 中 project 下的 topic batchSize 每批次都少条记录 serializer 序列化方式， DELIMITED 表示按分隔符切分 serializer.delimiter 具体分隔符是什么，这里“\\u007C” 表示 | Unicode 转中文工具地址： http://www.msxindl.com/tools/unicode16.asp serializer.fieldnames 切分后对应的字段名 serializer.charset 字符集 shard.number 分片数 shard.maxTimeOut 超时时间， 单位是秒 获取 AccessID 和 AccessKeyDataHub 服务并不是靠 IP 来定位的，而是靠阿里云账号，每个阿里云账号只能有一个DataHub，每个阿里云账号也会有唯一的 AccessID 和 AccessKey。所以通过 AccessId 和AccessKey 就可以直接锁定某个阿里云账号的 DataHub。1）悬浮鼠标到阿里云账号头像上-&gt;点击 accesskeys 2）点击继续使用 AccessKey 3）新用户需要点击创建 AccessKey 4）获取到 AccessKeyID 和 AccessKeySecret 值 查看接收数据1）启动 Flume 进程 /opt/module/flume/bin/flume-ng agent -n a1 -c /opt/module/flume/conf/ -f /opt/module/flume/conf/file-flume-datahub.conf -Dflume.root.logger=info,console 2）启动日志生成程序 java -jar log-collector-1.0-SNAPSHOT-jar-with-dependencies.jar &gt; /dev/null 2&gt;&amp;1 &amp; 3） 观察 DataHub 中数据量 DataWorks 和 MaxCompute简介MaxCompute（大数据计算服务）是阿里巴巴自主研发的海量数据处理平台，主要提供数据上传和下载通道，提供 SQL 及 MapReduce 等多种计算分析服务，同时还提供完善的安全解决方案。DataWorks（数据工场，原大数据开发套件） 是基于 MaxCompute 计算引擎的一站式大 数据工场，它能帮助您快速完成数据集成、开发、治理、服务、质量、安全等全套数据研发工作。 盘古： 相当于 Hadoop 中的 HDFS伏羲： 相当于 Hadoop 中的 YARNMaxCompute Engine： 相当于 MR、 Tez 等计算引擎MaxCompute 和 DataWorks 一起向用户提供完善的 ETL 和数仓管理能力，以及 SQL、MR、 Graph 等多种经典的分布式计算模型，能够更快速地解决用户海量数据计算问题，有效降低企业成本，保障数据安全。 用户行为数仓搭建数仓分层概念数仓分层 1） ODS 层原始数据层，存放原始数据，直接加载原始日志、数据，数据保持原貌不做处理。2） DWD 层对 ODS 层数据进行清洗（去除空值，脏数据，超过极限范围的数据）3） DWS 层以 DWD 为基础，进行轻度汇总。4） ADS 层为各种统计报表提供数据 数仓分层优点1）把复杂问题简单化将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单、并且方便定位问题。2）减少重复开发规范数据分层，通过的中间层数据，能够减少极大的重复计算，增加一次计算结果的复用性。3）隔离原始数据不论是数据的异常还是数据的敏感性，使真实数据与统计数据解耦开。 数仓命名规范ODS层命名为ods前缀DWD层命名为dwd前缀 DWS层命名为dws前缀 ADS层命名为ads前缀 维度表命名为dim前缀 每日全量导入命名为df（day full） 后缀 每日增量导入命名为di（day increase） 后缀 数仓分层配置建立业务流程1）点击数据开发-&gt;业务流程-&gt;新建业务流程-&gt;输入业务名称 2）再业务流程下面就可以看到业务 1 配置表主题1）进入配置中心点击最下方的齿轮，进入配置中心 2）配置主题管理，这里主要是划分表的主题 主题一般是表的对应的业务主题，比如：基础表、用户、商品、广告等对应的业务线。 配置表层级 在同一页面中， DataWorks 还提供了一个物理分类的划分维度，用户可以根据情况自行决定划分方式。本案例中，对数据表按照数据来源划分为，日志、数据库和综合。 原始数据层（ODS 层）用户行为数仓分层 建表语句1）回到数据开发的界面，按下图开始创建数据表 2）输入表名-&gt;提交 开始建立的表要和原始数据最基本的结构一致 。 配置基本属性配置新创建的表的主题。 配置物理模型注意选择层级和物理分类，由于建立的原始日志表，所以此处选择 ODS 层。分类是日志 从 DataHub 过来的数据必须选择分区表。如果手工文件导入的表可以选择非分区。为了减少再购买存储服务器， 所以选择内部表。真实企业开发时，大部分情况都是创建外部表，需要在 OSS 服务中申请存储空间。 配置字段发送过来的日志包含两部分： 服务器时间和日志详情。 这里面设计了两个字段对应接收。 注意：这里的主键，是指一个标志而已，本身不提供索引和唯一性约束。 配置分区表示数据按如下字段进行分区 由于目前 DataHub 至 MaxCompute 的接口，只支持按年月日+小时+分钟方式分区，所以这三个字段是必须有的，且字段类型必须是 String。 查看建表语句点击 DDL 模式，可以查看自动生成的建表语句。 和普通的创建表语句一样。 提交到生产环境点击提交到生产环境，表就创建完成了 。 表的基本操作查看表结构在最左侧菜单中选择【表管理】，可以在右侧查看表的结构信息。但是不可以修改。 在业务流程中导入表在业务 1 中建 ods、 dwd、 dws、 ads， 4 个文件夹 2）向 ods 文件夹中导入表 临时查询1） 点击临时查询-&gt;新建-&gt;ODPS SQL 2）创建临时查询节点 3）可以执行 SQL 命令 DataHub 推送数据到 MaxCompute如下图，之前 Flume 中的数据利用 DataHub Sink 把数据写入到了 DataHub 中， DataHub中提供了很多的其他第三方的 DataConnector 可以连接各种例如： MaxCompute， ElasticSearch，ADB， RDS 等数据库。 所以下面就要建立 DataConnector 把数据推送到 MaxCompute 中。 创建 DataConnector1）在 DataHub 中找到 Topic，在某个 Topic 下，点击右上角的 DataConnector 2） 点击同步到 MaxCompute 离线表 3） 创建 DataConnector （1） MaxCompute Project：名称要和 MaxCompute 创建的工作空间名称一致（ 2） MaxCompute Table： 数据导入到 MaxCompute 中的表名（ 3） AccessKey ID： LTAI4FiU71dZAL17SdLBa6Nt（ 4） AccessKey Secret： 63YzSmqMOSjDR5A2ZXEzFLM2tREY6m注意： AccessKey ID 和 AccessKey Secret 要和自己的阿里云账号一一对应（ 5）分区选项： system、 event_time通常采用 system 时间分区。如果是 event_time 方式分区，就要在 topic 中包含一个 event_time 的字段。不过这个字段与以往的 timestamp 不同的是，必须精确到微秒级。而且这个字段一旦用于分区，则不会再写入到实体表中。（ 6）分区范围： 15 分钟起 发送数据建立好表后 DataConnector 就可以尝试发送数据了。注意： 如果已经启动了 Flume，就不需要再次启动了。1）启动 Flume 程序 /opt/module/flume/bin/flume-ng agent-n a1 -c /opt/module/flume/conf/ -f /opt/module/flume/conf/file-flume-datahub.conf -Dflume.root.logger=info,console 2）在服务器 hadoop102 上执行命令 java -jar log-collector-1.0-SNAPSHOT-jar-with-dependencies.jar &gt; /dev/null 2&gt;&amp;1 &amp; 接收数据1） 观察 DataHub 中接收到数据（速度很快） 2）查看 MaxCompute 中接收到数据（1-5 分钟的延迟） 明细数据层（DWD 层）DWD 层主要是对 ODS 层数据进行清洗（去除空值，脏数据，超过极限范围的数据）。DWD 层处理后的表，能够成为非常明确可用的基础明细数据。本次项目中需要将用户行为过来基础日志，根据表类型，一张一张的解析出来 11 张不同类型的表数据，方便后续的处理。 日志格式分析1）日志格式：服务器时间 | json 2）其中 json 包括：cm：公共字段的 key；ap： app 的名称；et：具体事件 自定义 UDTF（解析具体事件字段）开发 UDTF 有两个方法： 方法 1：在本地 IDEA 中创建工程，开发代码，打包，把 JAR 上传到 DataStudio 成为资源 JAR 包。然后基于资源 JAR 包，声明函数。 方法 2：直接在 FunctionStudio 中开发，然后在线打包发布程序，声明函数。 相比而言，从发布流程上来说利用 FunctionStudio 更快捷方便。但是从 IDEA 开发角度来说，网页版本的 FunctionStudio，肯定不如客户端的功能强大、反应速度流畅。不过也可以两者配合起来使用。本次案例主要介绍通过 FunctionStudio 来编写 UDTF 函数。1） 按下图所示，打开 FunctionStudio 的界面 2）创建工程 3）选择命名工程名，选择 udfjava 4）添加代码文件 可以看到工程创建好后，默认有很多参考的模板。 5）在 udtf 目录下创建一个 FlatEventUDTF 类 6）编写代码 首先分析日志结构 1）在 pom.xml 中要加入 fastJson 依赖 12345&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;/groupId&gt;&lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;version&gt;1.2.28.odps&lt;/version&gt;&lt;/dependency&gt; （ 2）编写自定义 UDTF 代码 12345678910111213141516171819202122232425262728import com.aliyun.odps.udf.ExecutionContext;import com.aliyun.odps.udf.UDFException;import com.aliyun.odps.udf.UDTF;import com.aliyun.odps.udf.annotation.Resolve;import com.alibaba.fastjson.*;// TODO define input and output types, e.g.\"string,string-&gt;string,bigint\".@Resolve(&#123;\"string-&gt;bigint,string,string\"&#125;)public class FlatEventUDTF extends UDTF &#123;@Overridepublic void setup(ExecutionContext ctx) throws UDFException&#123; &#125;@Overridepublic void process(Object[] args) throws UDFException &#123;String event =(String) args[0];JSONArray jsonArray = JSON.parseArray(event);for (int i = 0; i &lt; jsonArray.size(); i++) &#123;JSONObject jsonObject = jsonArray.getJSONObject(i);String ett =(String) jsonObject.getString(\"ett\");String eventName =(String) jsonObject.getString(\"en\");String eventJson =(String) jsonObject.getString(\"kv\");forward(Long.parseLong(ett),eventName,eventJson);&#125;&#125;@Overridepublic void close() throws UDFException &#123;&#125;&#125; 其中， @Resolve({“string-&gt;bigint,string,string”} 表示该函数，传入参数是 string，返回参数是三个，分别为长整型，和两个字符串，对应的返回值就是事件的时间、事件名称和事件内容（json 格式）。 7）打包部署 （1）提交到 Data Studio 开发环境 （2）提交函数详情 （ 3）提交函数过程，控制台打印 提交成功后 ，回到 DataWorks 中的资源菜单中可以看到增加了 1 个 JAR 包，函数菜单中可以看到定义的函数。 8）测试函数在 DataStudio 中临时查询，执行如下语句 12345selectFlatEventUDTF(GET_JSON_OBJECT(log_string,'$.et')) as(event_time, event_name, event_json)from ods_base_logwhere ds='20191008'; 能看到如下结果表示运行正确 DWD 层建表（启动日志表）在流程中建立表，在 DWD 文件夹中增加一个 dwd_start_log 的表，可以直接用 ddl 模式建立，再进行微调。 1） 在业务 1 的表上，右键新建表 2）点击 DDL 模式 3） 在 DDL 模式中添加建表语句 详细建表语句如下 12345678910111213141516171819202122232425CREATE TABLE `dwd_start_log` (`mid` string,`user_id` string,`version_code` string,`version_name` string,`lang` string,`source` string,`os` string,`area` string,`model` string,`brand` string,`sdk_version` string,`email` string,`height_width` string,`network` string,`lng` string,`lat` string,`entry` string,`open_ad_type` string,`action` string,`loading_time` string,`detail` string,`event_time` string COMMENT '事件时间')PARTITIONED BY (ds string, hh string, mm string); 4）补充一些相关字段。 5）补充分区格式 6）提交到生产环境 手动将 ODS 层数据导入 DWD 层1）在临时查询页面， 把 ods 层 ods_base_log 里面的数据导入到 dwd_start_log 123456789101112131415161718192021222324252627282930313233INSERT OVERWRITE TABLE dwd_start_log PARTITION (ds,hh,mm)selectGET_JSON_OBJECT(log_string,'$.cm.mid') mid,GET_JSON_OBJECT(log_string,'$.cm.uid') user_id,GET_JSON_OBJECT(log_string,'$.cm.vc') version_code,GET_JSON_OBJECT(log_string,'$.cm.vn') version_name,GET_JSON_OBJECT(log_string,'$.cm.l') lang,GET_JSON_OBJECT(log_string,'$.cm.sr') source,GET_JSON_OBJECT(log_string,'$.cm.os') os,GET_JSON_OBJECT(log_string,'$.cm.ar') area,GET_JSON_OBJECT(log_string,'$.cm.md') model,GET_JSON_OBJECT(log_string,'$.cm.ba') brand,GET_JSON_OBJECT(log_string,'$.cm.sv') sdk_version,GET_JSON_OBJECT(log_string,'$.cm.hw') height_width,GET_JSON_OBJECT(log_string,'$.cm.g') email,GET_JSON_OBJECT(log_string,'$.cm.hw') sv,GET_JSON_OBJECT(log_string,'$.cm.ln') ln,GET_JSON_OBJECT(log_string,'$.cm.la') la,GET_JSON_OBJECT( event_view.event_json,'$.entry') entry,GET_JSON_OBJECT( event_view.event_json,'$.loading_time')loading_time,GET_JSON_OBJECT( event_view.event_json,'$.action') action,GET_JSON_OBJECT( event_view.event_json,'$.open_ad_type')open_ad_type,GET_JSON_OBJECT( event_view.event_json,'$.detail') detail ,event_view.event_time,ds,hh,mmfrom ods_base_logLATERAL VIEW FlatEventUDTF(GET_JSON_OBJECT(log_string,'$.et' ))event_view as event_time,event_name,event_jsonwhere ds='20191008' and event_view.event_name = 'start'; 注意: get_json_object函数的作用：用来解析json字符串的一个字段 2）在临时查询中查看导入结果 1SELECT * from dwd_start_log WHERE ds='20191008'; 数据导入脚本1）在流程中加入一个ODPS数据开发SQL脚本 123456789101112131415161718192021222324252627282930313233INSERT OVERWRITE TABLE dwd_start_log PARTITION (ds,hh,mm)selectGET_JSON_OBJECT(log_string,'$.cm.mid') mid,GET_JSON_OBJECT(log_string,'$.cm.uid') user_id,GET_JSON_OBJECT(log_string,'$.cm.vc') version_code,GET_JSON_OBJECT(log_string,'$.cm.vn') version_name,GET_JSON_OBJECT(log_string,'$.cm.l') lang,GET_JSON_OBJECT(log_string,'$.cm.sr') source,GET_JSON_OBJECT(log_string,'$.cm.os') os,GET_JSON_OBJECT(log_string,'$.cm.ar') area,GET_JSON_OBJECT(log_string,'$.cm.md') model,GET_JSON_OBJECT(log_string,'$.cm.ba') brand,GET_JSON_OBJECT(log_string,'$.cm.sv') sdk_version,GET_JSON_OBJECT(log_string,'$.cm.hw') height_width,GET_JSON_OBJECT(log_string,'$.cm.g') email,GET_JSON_OBJECT(log_string,'$.cm.hw') sv,GET_JSON_OBJECT(log_string,'$.cm.ln') ln,GET_JSON_OBJECT(log_string,'$.cm.la') la,GET_JSON_OBJECT( event_view.event_json,'$.entry') entry,GET_JSON_OBJECT( event_view.event_json,'$.loading_time')loading_time,GET_JSON_OBJECT( event_view.event_json,'$.action') action,GET_JSON_OBJECT( event_view.event_json,'$.open_ad_type')open_ad_type,GET_JSON_OBJECT( event_view.event_json,'$.detail') detail,event_view.event_time,ds,hh,mmfrom ods_base_logLATERAL VIEW FlatEventUdtf (GET_JSON_OBJECT(log_string,'$.et' ))event_view as event_time,event_name,event_jsonwhere ds='$&#123;bizdate&#125;' and event_view.event_name = 'start' ; 注意： 在上面的 SQL 中我们使用了一个${bizedate}作为外部传入的日期参数 。 2）配置参数在执行或者调度该脚本的时候传入相应的参数。 （ 1）在右侧有一个调度配置，打开可以对参数进行设置。 注意：这里参数设置用的是花括号， bizdate=${yyyymmdd}， 表示取前一日的日期；如果采用方括号，如， bizdate= $[yyyymmdd]， 表示取当前日期。 （ 2）配置脚本执行时间 服务数据层（DWS 层）需求：日活统计 建表语句1） 创建表 dws_uv_detail_d 2）点击 DDL 模式 3） 在 DDL 模式中添加建表语句 123456789101112131415161718192021CREATE TABLE `dws_uv_detail_d` (`mid` string COMMENT '设备唯一标识',`user_id` string COMMENT '用户标识',`version_code` string COMMENT '程序版本号',`version_name` string COMMENT '程序版本名',`lang` string COMMENT '系统语言',`source` string COMMENT '渠道号',`os` string COMMENT '系统版本',`area` string COMMENT '区域',`model` string COMMENT '手机型号',`brand` string COMMENT '手机品牌',`sdk_version` string COMMENT 'sdkversion',`email` string COMMENT 'email',`height_width` string COMMENT '屏幕宽高',`network` string COMMENT '网络模式',`lng` string COMMENT '经度',`lat` string COMMENT '纬度',`event_time` bigint)COMMENT '活跃用户按天明细'PARTITIONED BY (ds string,hh string,mm string); 4）补全建表信息描述 5）提交到生产环境 手动将 DWD 层数据导入 DWS 层1）在临时查询页面， 把 DWD 层 dwd_start_log 里面的数据导入到 dws_uv_detail_d 12345678910111213141516171819202122232425262728293031insert overwrite table dws_uv_detail_d partition(ds,hh,mm)selectmid,user_id,version_code,version_name,lang,source,os,area,model,brand,sdk_version,email,height_width,network,lng,lat,event_time,ds,hh,mmfrom(select*,ROW_NUMBER() OVER(PARTITION BY mid ORDER BY event_timeasc) rnfrom dwd_start_logwhere ds='20191008') st where rn = 1; 2）查看导入结果 SELECT * from dws_uv_detail_d WHERE ds=’20191008’; 数据导入脚本DWS 层一般围绕某个主题进行聚合、拼接处理。针对统计日活的需求， DWS 主要的工作就进行以日为单位的去重操作。 1）在流程中加入一个数据开发脚本 12345678910111213141516171819202122232425262728293031insert overwrite table dws_uv_detail_d partition(ds,hh,mm)selectmid,user_id,version_code,version_name,lang,source,os,area,model,brand,sdk_version,email,height_width,network,lng,lat,event_time,ds,hh,mmfrom(select*,ROW_NUMBER() OVER(PARTITION BY mid ORDER BY event_timeasc) rnfrom dwd_start_logwhere ds = '$&#123;bizdate&#125;') st where rn = 1; 2）配置参数点击调度配置-&gt; bizdate=${yyyymmdd} 应用数据层（ADS 层）统计各个渠道的 uv 个数 建表语句1） 创建表 ads_uv_source_d 2）点击 DDL 模式 3） 在 DDL 模式中添加建表语句 123456CREATE TABLE `ads_uv_source_d` (`source` string COMMENT '渠道',`ct` bigint COMMENT '个数')COMMENT '日活渠道统计'PARTITIONED BY (ds string); 4）补全建表信息描述 5）提交到生产环境 ads层数据导入脚本1）在流程中加入一个数据开发脚本 12345678insert OVERWRITE table ads_uv_source_d PARTITION(ds='$&#123;bizdate&#125;')SELECTsource,COUNT(*) ctfrom dws_uv_detail_dwhere ds='$&#123;bizdate&#125;'group by source; 2）配置参数点击调度配置-&gt; bizdate=${yyyymmdd} 日活需求： 全流程业务调度1）点击业务 1， 右侧就会出现之前写的脚本。默认三个脚本之间没有关系，可以根据业务需求，手动连线。 2）点击执行 3）查询运行日志 4）临时查询， 检查结果 1SELECT * from ads_uv_source_d WHERE ds='20191008'; to be continued…","categories":[],"tags":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://yixiangdong.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}]}]}